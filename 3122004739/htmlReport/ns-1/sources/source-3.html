


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=GBK"> 
  <title>Coverage Report > SimHashUtil</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">&lt;empty package name&gt;</a>
</div>

<h1>Coverage Summary for Class: SimHashUtil (&lt;empty package name&gt;)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SimHashUtil</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    89.3%
  </span>
  <span class="absValue">
    (25/28)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94%
  </span>
  <span class="absValue">
    (47/50)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;import com.hankcs.hanlp.seg.common.Term;
&nbsp;import com.hankcs.hanlp.tokenizer.StandardTokenizer;
&nbsp;import java.math.BigInteger;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;
&nbsp;/**
&nbsp; * 生成文本指纹类
&nbsp; * @author J
&nbsp; */
<b class="nc">&nbsp;public class SimHashUtil {</b>
&nbsp;    /**
&nbsp;     * 文本指纹hash的位数
&nbsp;     */
&nbsp;    public static final int HASH_BITS = 64;
&nbsp;    private static final int MIN_WORD_LENGTH = 3;
&nbsp;    private static final String HASH_LMT = &quot;-1&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * 生成文本指纹
&nbsp;     * @param context 文本
&nbsp;     * @return 文本指纹
&nbsp;     */
&nbsp;    public static BigInteger simHash(String context) {
<b class="fc">&nbsp;        int[] vector = new int[HASH_BITS];</b>
&nbsp;        // 对字符串进行分词
<b class="fc">&nbsp;        List&lt;Term&gt; termList = StandardTokenizer.segment(context);</b>
&nbsp;        //词性的权重
<b class="fc">&nbsp;        Map&lt;String, Integer&gt; weightOfNature = new HashMap&lt;&gt;(16);</b>
&nbsp;        //给名词的权重是2
<b class="fc">&nbsp;        weightOfNature.put(&quot;n&quot;, 2);</b>
&nbsp;        // 停用的词性
<b class="fc">&nbsp;        Map&lt;String, String&gt; stopNatures = new HashMap&lt;&gt;(16);</b>
&nbsp;        //停用标点符号
<b class="fc">&nbsp;        stopNatures.put(&quot;w&quot;, &quot;&quot;);</b>
&nbsp;        //设定超频词汇的界限
<b class="fc">&nbsp;        int overCount = 50;</b>
<b class="fc">&nbsp;        Map&lt;String, Integer&gt; wordCount = new HashMap&lt;&gt;(16);</b>
<b class="fc">&nbsp;        for (Term term : termList) {</b>
&nbsp;            //分词字符串
<b class="fc">&nbsp;            String word = term.word;</b>
&nbsp;            // 分词属性
<b class="fc">&nbsp;            String nature = term.nature.toString();</b>
<b class="fc">&nbsp;            if (wordCount.containsKey(word)) {</b>
<b class="fc">&nbsp;                int count = wordCount.get(word);</b>
&nbsp;                //超频词过滤
<b class="fc">&nbsp;                if (count &gt; overCount) {</b>
&nbsp;                    continue;
&nbsp;                }
<b class="fc">&nbsp;                wordCount.put(word, count + 1);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                wordCount.put(word, 1);</b>
&nbsp;            }
&nbsp;            // 过滤停用词性
<b class="fc">&nbsp;            if (stopNatures.containsKey(nature)) {</b>
&nbsp;                continue;
&nbsp;            }
&nbsp;            //将每一个分词hash为一组固定长度的数列
<b class="fc">&nbsp;            BigInteger hash = hash(word);</b>
<b class="fc">&nbsp;            for (int i = 0; i &lt; HASH_BITS; i++) {</b>
<b class="fc">&nbsp;                BigInteger bitmask = new BigInteger(&quot;1&quot;).shiftLeft(i);</b>
&nbsp;                //添加权重
<b class="fc">&nbsp;                int weight = 1;</b>
<b class="fc">&nbsp;                if (weightOfNature.containsKey(nature)) {</b>
<b class="fc">&nbsp;                    weight = weightOfNature.get(nature);</b>
&nbsp;                }
<b class="fc">&nbsp;                if (hash.and(bitmask).signum() != 0) {</b>
&nbsp;                    // 这里是计算整个文档的所有特征的向量和
<b class="fc">&nbsp;                    vector[i] += weight;</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    vector[i] -= weight;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        BigInteger simHash = new BigInteger(&quot;0&quot;);</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; HASH_BITS; i++) {</b>
<b class="fc">&nbsp;            if (vector[i] &gt;= 0) {</b>
<b class="fc">&nbsp;                simHash = simHash.add(new BigInteger(&quot;1&quot;).shiftLeft(i));</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return simHash;</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * 处理单个分词的hash
&nbsp;     * @param word 分词
&nbsp;     * @return 分词的hash
&nbsp;     */
&nbsp;    private static BigInteger hash(String word) {
<b class="pc">&nbsp;        if (word == null || word.isEmpty()) {</b>
<b class="nc">&nbsp;            return new BigInteger(&quot;0&quot;);</b>
&nbsp;        } else {
&nbsp;            //word 的长度过短，会导致hash算法失效，因此需要对过短的词补偿
<b class="fc">&nbsp;            StringBuilder wordBuilder = new StringBuilder(word);</b>
<b class="fc">&nbsp;            while (wordBuilder.length() &lt; MIN_WORD_LENGTH) {</b>
<b class="fc">&nbsp;                wordBuilder.append(wordBuilder.charAt(0));</b>
&nbsp;            }
<b class="fc">&nbsp;            word = wordBuilder.toString();</b>
<b class="fc">&nbsp;            return getWordHash(word);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * 对单个的分词进行hash计算;
&nbsp;     * @param word 分词
&nbsp;     * @return 分词的hash
&nbsp;     */
&nbsp;    private static BigInteger getWordHash(String word) {
<b class="fc">&nbsp;        char[] wordCharArray = word.toCharArray();</b>
<b class="fc">&nbsp;        BigInteger x = BigInteger.valueOf(((long) wordCharArray[0]) &lt;&lt; 7);</b>
<b class="fc">&nbsp;        BigInteger m = new BigInteger(&quot;1000003&quot;);</b>
<b class="fc">&nbsp;        BigInteger mask = new BigInteger(&quot;2&quot;).pow(HASH_BITS).subtract(new BigInteger(&quot;1&quot;));</b>
<b class="fc">&nbsp;        for (char item : wordCharArray) {</b>
<b class="fc">&nbsp;            BigInteger temp = BigInteger.valueOf(item);</b>
<b class="fc">&nbsp;            x = x.multiply(m).xor(temp).and(mask);</b>
&nbsp;        }
<b class="fc">&nbsp;        x = x.xor(new BigInteger(String.valueOf(word.length())));</b>
<b class="pc">&nbsp;        if (x.equals(new BigInteger(HASH_LMT))) {</b>
<b class="nc">&nbsp;            x = new BigInteger(&quot;-2&quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        return x;</b>
&nbsp;    }
&nbsp;
&nbsp;}
&nbsp;
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-09-11 16:59</div>
</div>
</body>
</html>
